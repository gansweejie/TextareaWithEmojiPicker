/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/emoji-picker-element@1.22.8/database.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function assertNonEmptyString(e) {
  if ("string" != typeof e || !e)
    throw new Error("expected a non-empty string, got: " + e);
}
function assertNumber(e) {
  if ("number" != typeof e) throw new Error("expected a number, got: " + e);
}
const DB_VERSION_CURRENT = 1,
  DB_VERSION_INITIAL = 1,
  STORE_EMOJI = "emoji",
  STORE_KEYVALUE = "keyvalue",
  STORE_FAVORITES = "favorites",
  FIELD_TOKENS = "tokens",
  INDEX_TOKENS = "tokens",
  FIELD_UNICODE = "unicode",
  INDEX_COUNT = "count",
  FIELD_GROUP = "group",
  FIELD_ORDER = "order",
  INDEX_GROUP_AND_ORDER = "group-order",
  KEY_ETAG = "eTag",
  KEY_URL = "url",
  KEY_PREFERRED_SKINTONE = "skinTone",
  MODE_READONLY = "readonly",
  MODE_READWRITE = "readwrite",
  INDEX_SKIN_UNICODE = "skinUnicodes",
  FIELD_SKIN_UNICODE = "skinUnicodes",
  DEFAULT_DATA_SOURCE =
    "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json",
  DEFAULT_LOCALE = "en";
function uniqBy(e, t) {
  const n = new Set(),
    o = [];
  for (const r of e) {
    const e = t(r);
    n.has(e) || (n.add(e), o.push(r));
  }
  return o;
}
function uniqEmoji(e) {
  return uniqBy(e, (e) => e.unicode);
}
function initialMigration(e) {
  function t(t, n, o) {
    const r = n
      ? e.createObjectStore(t, { keyPath: n })
      : e.createObjectStore(t);
    if (o)
      for (const [e, [t, n]] of Object.entries(o))
        r.createIndex(e, t, { multiEntry: n });
    return r;
  }
  t(STORE_KEYVALUE),
    t(STORE_EMOJI, FIELD_UNICODE, {
      [INDEX_TOKENS]: [FIELD_TOKENS, !0],
      [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],
      [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, !0],
    }),
    t(STORE_FAVORITES, void 0, { [INDEX_COUNT]: [""] });
}
const openIndexedDBRequests = {},
  databaseCache = {},
  onCloseListeners = {};
function handleOpenOrDeleteReq(e, t, n) {
  (n.onerror = () => t(n.error)),
    (n.onblocked = () => t(new Error("IDB blocked"))),
    (n.onsuccess = () => e(n.result));
}
async function createDatabase(e) {
  const t = await new Promise((t, n) => {
    const o = indexedDB.open(e, DB_VERSION_CURRENT);
    (openIndexedDBRequests[e] = o),
      (o.onupgradeneeded = (e) => {
        e.oldVersion < DB_VERSION_INITIAL && initialMigration(o.result);
      }),
      handleOpenOrDeleteReq(t, n, o);
  });
  return (t.onclose = () => closeDatabase(e)), t;
}
function openDatabase(e) {
  return (
    databaseCache[e] || (databaseCache[e] = createDatabase(e)), databaseCache[e]
  );
}
function dbPromise(e, t, n, o) {
  return new Promise((r, s) => {
    const a = e.transaction(t, n, { durability: "relaxed" }),
      i =
        "string" == typeof t
          ? a.objectStore(t)
          : t.map((e) => a.objectStore(e));
    let c;
    o(i, a, (e) => {
      c = e;
    }),
      (a.oncomplete = () => r(c)),
      (a.onerror = () => s(a.error));
  });
}
function closeDatabase(e) {
  const t = openIndexedDBRequests[e],
    n = t && t.result;
  if (n) {
    n.close();
    const t = onCloseListeners[e];
    if (t) for (const e of t) e();
  }
  delete openIndexedDBRequests[e],
    delete databaseCache[e],
    delete onCloseListeners[e];
}
function deleteDatabase(e) {
  return new Promise((t, n) => {
    closeDatabase(e);
    handleOpenOrDeleteReq(t, n, indexedDB.deleteDatabase(e));
  });
}
function addOnCloseListener(e, t) {
  let n = onCloseListeners[e];
  n || (n = onCloseListeners[e] = []), n.push(t);
}
const irregularEmoticons = new Set([
  ":D",
  "XD",
  ":'D",
  "O:)",
  ":X",
  ":P",
  ";P",
  "XP",
  ":L",
  ":Z",
  ":j",
  "8D",
  "XO",
  "8)",
  ":B",
  ":O",
  ":S",
  ":'o",
  "Dx",
  "X(",
  "D:",
  ":C",
  ">0)",
  ":3",
  "</3",
  "<3",
  "\\M/",
  ":E",
  "8#",
]);
function extractTokens(e) {
  return e
    .split(/[\s_]+/)
    .map((e) =>
      !e.match(/\w/) || irregularEmoticons.has(e)
        ? e.toLowerCase()
        : e
            .replace(/[)(:,]/g, "")
            .replace(/’/g, "'")
            .toLowerCase()
    )
    .filter(Boolean);
}
const MIN_SEARCH_TEXT_LENGTH = 2;
function normalizeTokens(e) {
  return e
    .filter(Boolean)
    .map((e) => e.toLowerCase())
    .filter((e) => e.length >= MIN_SEARCH_TEXT_LENGTH);
}
function transformEmojiData(e) {
  return e.map(
    ({
      annotation: e,
      emoticon: t,
      group: n,
      order: o,
      shortcodes: r,
      skins: s,
      tags: a,
      emoji: i,
      version: c,
    }) => {
      const u = {
        annotation: e,
        group: n,
        order: o,
        tags: a,
        tokens: [
          ...new Set(
            normalizeTokens([
              ...(r || []).map(extractTokens).flat(),
              ...(a || []).map(extractTokens).flat(),
              ...extractTokens(e),
              t,
            ])
          ),
        ].sort(),
        unicode: i,
        version: c,
      };
      if ((t && (u.emoticon = t), r && (u.shortcodes = r), s)) {
        (u.skinTones = []), (u.skinUnicodes = []), (u.skinVersions = []);
        for (const { tone: e, emoji: t, version: n } of s)
          u.skinTones.push(e), u.skinUnicodes.push(t), u.skinVersions.push(n);
      }
      return u;
    }
  );
}
function callStore(e, t, n, o) {
  e[t](n).onsuccess = (e) => o && o(e.target.result);
}
function getIDB(e, t, n) {
  callStore(e, "get", t, n);
}
function getAllIDB(e, t, n) {
  callStore(e, "getAll", t, n);
}
function commit(e) {
  e.commit && e.commit();
}
function minBy(e, t) {
  let n = e[0];
  for (let o = 1; o < e.length; o++) {
    const r = e[o];
    t(n) > t(r) && (n = r);
  }
  return n;
}
function findCommonMembers(e, t) {
  const n = minBy(e, (e) => e.length),
    o = [];
  for (const r of n)
    e.some((e) => -1 === e.findIndex((e) => t(e) === t(r))) || o.push(r);
  return o;
}
async function isEmpty(e) {
  return !(await get(e, STORE_KEYVALUE, KEY_URL));
}
async function hasData(e, t, n) {
  const [o, r] = await Promise.all(
    [KEY_ETAG, KEY_URL].map((t) => get(e, STORE_KEYVALUE, t))
  );
  return o === n && r === t;
}
async function doFullDatabaseScanForSingleResult(e, t) {
  return dbPromise(e, STORE_EMOJI, MODE_READONLY, (e, n, o) => {
    let r;
    const s = () => {
      e.getAll(r && IDBKeyRange.lowerBound(r, !0), 50).onsuccess = (e) => {
        const n = e.target.result;
        for (const e of n) if (((r = e.unicode), t(e))) return o(e);
        if (n.length < 50) return o();
        s();
      };
    };
    s();
  });
}
async function loadData(e, t, n, o) {
  try {
    const r = transformEmojiData(t);
    await dbPromise(
      e,
      [STORE_EMOJI, STORE_KEYVALUE],
      MODE_READWRITE,
      ([e, t], s) => {
        let a,
          i,
          c = 0;
        function u() {
          2 == ++c &&
            (function () {
              if (a === o && i === n) return;
              e.clear();
              for (const t of r) e.put(t);
              t.put(o, KEY_ETAG), t.put(n, KEY_URL), commit(s);
            })();
        }
        getIDB(t, KEY_ETAG, (e) => {
          (a = e), u();
        }),
          getIDB(t, KEY_URL, (e) => {
            (i = e), u();
          });
      }
    );
  } finally {
  }
}
async function getEmojiByGroup(e, t) {
  return dbPromise(e, STORE_EMOJI, MODE_READONLY, (e, n, o) => {
    const r = IDBKeyRange.bound([t, 0], [t + 1, 0], !1, !0);
    getAllIDB(e.index(INDEX_GROUP_AND_ORDER), r, o);
  });
}
async function getEmojiBySearchQuery(e, t) {
  const n = normalizeTokens(extractTokens(t));
  return n.length
    ? dbPromise(e, STORE_EMOJI, MODE_READONLY, (e, t, o) => {
        const r = [],
          s = () => {
            const e = findCommonMembers(r, (e) => e.unicode);
            o(e.sort((e, t) => (e.order < t.order ? -1 : 1)));
          };
        for (let t = 0; t < n.length; t++) {
          const o = n[t],
            a =
              t === n.length - 1
                ? IDBKeyRange.bound(o, o + "￿", !1, !0)
                : IDBKeyRange.only(o);
          getAllIDB(e.index(INDEX_TOKENS), a, (e) => {
            r.push(e), r.length === n.length && s();
          });
        }
      })
    : [];
}
async function getEmojiByShortcode(e, t) {
  const n = await getEmojiBySearchQuery(e, t);
  if (!n.length) {
    const n = (e) => (e.shortcodes || []).includes(t.toLowerCase());
    return (await doFullDatabaseScanForSingleResult(e, n)) || null;
  }
  return (
    n.filter((e) => {
      const n = (e.shortcodes || []).map((e) => e.toLowerCase());
      return n.includes(t.toLowerCase());
    })[0] || null
  );
}
async function getEmojiByUnicode(e, t) {
  return dbPromise(e, STORE_EMOJI, MODE_READONLY, (e, n, o) =>
    getIDB(e, t, (n) => {
      if (n) return o(n);
      getIDB(e.index(INDEX_SKIN_UNICODE), t, (e) => o(e || null));
    })
  );
}
function get(e, t, n) {
  return dbPromise(e, t, MODE_READONLY, (e, t, o) => getIDB(e, n, o));
}
function set(e, t, n, o) {
  return dbPromise(e, t, MODE_READWRITE, (e, t) => {
    e.put(o, n), commit(t);
  });
}
function incrementFavoriteEmojiCount(e, t) {
  return dbPromise(e, STORE_FAVORITES, MODE_READWRITE, (e, n) =>
    getIDB(e, t, (o) => {
      e.put((o || 0) + 1, t), commit(n);
    })
  );
}
function getTopFavoriteEmoji(e, t, n) {
  return 0 === n
    ? []
    : dbPromise(
        e,
        [STORE_FAVORITES, STORE_EMOJI],
        MODE_READONLY,
        ([e, o], r, s) => {
          const a = [];
          e.index(INDEX_COUNT).openCursor(void 0, "prev").onsuccess = (e) => {
            const r = e.target.result;
            if (!r) return s(a);
            function i(e) {
              if ((a.push(e), a.length === n)) return s(a);
              r.continue();
            }
            const c = r.primaryKey,
              u = t.byName(c);
            if (u) return i(u);
            getIDB(o, c, (e) => {
              if (e) return i(e);
              r.continue();
            });
          };
        }
      );
}
const CODA_MARKER = "";
function trie(e, t) {
  const n = new Map();
  for (const o of e) {
    const e = t(o);
    for (const t of e) {
      let e = n;
      for (let n = 0; n < t.length; n++) {
        const o = t.charAt(n);
        let r = e.get(o);
        r || ((r = new Map()), e.set(o, r)), (e = r);
      }
      let r = e.get(CODA_MARKER);
      r || ((r = []), e.set(CODA_MARKER, r)), r.push(o);
    }
  }
  return (e, t) => {
    let o = n;
    for (let t = 0; t < e.length; t++) {
      const n = e.charAt(t),
        r = o.get(n);
      if (!r) return [];
      o = r;
    }
    if (t) {
      return o.get(CODA_MARKER) || [];
    }
    const r = [],
      s = [o];
    for (; s.length; ) {
      const e = [...s.shift().entries()].sort((e, t) => (e[0] < t[0] ? -1 : 1));
      for (const [t, n] of e) t === CODA_MARKER ? r.push(...n) : s.push(n);
    }
    return r;
  };
}
const requiredKeys$1 = ["name", "url"];
function assertCustomEmojis(e) {
  const t = e && Array.isArray(e),
    n = t && e.length && (!e[0] || requiredKeys$1.some((t) => !(t in e[0])));
  if (!t || n) throw new Error("Custom emojis are in the wrong format");
}
function customEmojiIndex(e) {
  assertCustomEmojis(e);
  const t = (e, t) => (e.name.toLowerCase() < t.name.toLowerCase() ? -1 : 1),
    n = e.sort(t),
    o = trie(e, (e) => {
      const t = new Set();
      if (e.shortcodes)
        for (const n of e.shortcodes)
          for (const e of extractTokens(n)) t.add(e);
      return t;
    }),
    r = (e) => o(e, !0),
    s = (e) => o(e, !1),
    a = new Map(),
    i = new Map();
  for (const t of e) {
    i.set(t.name.toLowerCase(), t);
    for (const e of t.shortcodes || []) a.set(e.toLowerCase(), t);
  }
  return {
    all: n,
    search: (e) => {
      const n = extractTokens(e);
      return findCommonMembers(
        n.map((e, t) => (t < n.length - 1 ? r : s)(e)),
        (e) => e.name
      ).sort(t);
    },
    byShortcode: (e) => a.get(e.toLowerCase()),
    byName: (e) => i.get(e.toLowerCase()),
  };
}
const isFirefoxContentScript = "undefined" != typeof wrappedJSObject;
function cleanEmoji(e) {
  if (!e) return e;
  if (
    (isFirefoxContentScript && (e = structuredClone(e)),
    delete e.tokens,
    e.skinTones)
  ) {
    const t = e.skinTones.length;
    e.skins = Array(t);
    for (let n = 0; n < t; n++)
      e.skins[n] = {
        tone: e.skinTones[n],
        unicode: e.skinUnicodes[n],
        version: e.skinVersions[n],
      };
    delete e.skinTones, delete e.skinUnicodes, delete e.skinVersions;
  }
  return e;
}
function warnETag(e) {
  e ||
    console.warn(
      "emoji-picker-element is more efficient if the dataSource server exposes an ETag header."
    );
}
const requiredKeys = ["annotation", "emoji", "group", "order", "version"];
function assertEmojiData(e) {
  if (
    !e ||
    !Array.isArray(e) ||
    !e[0] ||
    "object" != typeof e[0] ||
    requiredKeys.some((t) => !(t in e[0]))
  )
    throw new Error("Emoji data is in the wrong format");
}
function assertStatus(e, t) {
  if (2 !== Math.floor(e.status / 100))
    throw new Error("Failed to fetch: " + t + ":  " + e.status);
}
async function getETag(e) {
  const t = await fetch(e, { method: "HEAD" });
  assertStatus(t, e);
  const n = t.headers.get("etag");
  return warnETag(n), n;
}
async function getETagAndData(e) {
  const t = await fetch(e);
  assertStatus(t, e);
  const n = t.headers.get("etag");
  warnETag(n);
  const o = await t.json();
  return assertEmojiData(o), [n, o];
}
function arrayBufferToBinaryString(e) {
  for (var t = "", n = new Uint8Array(e), o = n.byteLength, r = -1; ++r < o; )
    t += String.fromCharCode(n[r]);
  return t;
}
function binaryStringToArrayBuffer(e) {
  for (
    var t = e.length, n = new ArrayBuffer(t), o = new Uint8Array(n), r = -1;
    ++r < t;

  )
    o[r] = e.charCodeAt(r);
  return n;
}
async function jsonChecksum(e) {
  let t = binaryStringToArrayBuffer(JSON.stringify(e));
  const n = arrayBufferToBinaryString(await crypto.subtle.digest("SHA-1", t));
  return btoa(n);
}
async function checkForUpdates(e, t) {
  let n,
    o = await getETag(t);
  if (!o) {
    const e = await getETagAndData(t);
    (o = e[0]), (n = e[1]), o || (o = await jsonChecksum(n));
  }
  if (await hasData(e, t, o));
  else {
    if (!n) {
      n = (await getETagAndData(t))[1];
    }
    await loadData(e, n, t, o);
  }
}
async function loadDataForFirstTime(e, t) {
  let [n, o] = await getETagAndData(t);
  n || (n = await jsonChecksum(o)), await loadData(e, o, t, n);
}
class Database {
  constructor({
    dataSource: e = DEFAULT_DATA_SOURCE,
    locale: t = "en",
    customEmoji: n = [],
  } = {}) {
    (this.dataSource = e),
      (this.locale = t),
      (this._dbName = `emoji-picker-element-${this.locale}`),
      (this._db = void 0),
      (this._lazyUpdate = void 0),
      (this._custom = customEmojiIndex(n)),
      (this._clear = this._clear.bind(this)),
      (this._ready = this._init());
  }
  async _init() {
    const e = (this._db = await openDatabase(this._dbName));
    addOnCloseListener(this._dbName, this._clear);
    const t = this.dataSource;
    (await isEmpty(e))
      ? await loadDataForFirstTime(e, t)
      : (this._lazyUpdate = checkForUpdates(e, t));
  }
  async ready() {
    const e = async () => (
      this._ready || (this._ready = this._init()), this._ready
    );
    await e(), this._db || (await e());
  }
  async getEmojiByGroup(e) {
    return (
      assertNumber(e),
      await this.ready(),
      uniqEmoji(await getEmojiByGroup(this._db, e)).map(cleanEmoji)
    );
  }
  async getEmojiBySearchQuery(e) {
    assertNonEmptyString(e), await this.ready();
    return [
      ...this._custom.search(e),
      ...uniqEmoji(await getEmojiBySearchQuery(this._db, e)).map(cleanEmoji),
    ];
  }
  async getEmojiByShortcode(e) {
    assertNonEmptyString(e), await this.ready();
    const t = this._custom.byShortcode(e);
    return t || cleanEmoji(await getEmojiByShortcode(this._db, e));
  }
  async getEmojiByUnicodeOrName(e) {
    assertNonEmptyString(e), await this.ready();
    const t = this._custom.byName(e);
    return t || cleanEmoji(await getEmojiByUnicode(this._db, e));
  }
  async getPreferredSkinTone() {
    return (
      await this.ready(), (await get(this._db, STORE_KEYVALUE, "skinTone")) || 0
    );
  }
  async setPreferredSkinTone(e) {
    return (
      assertNumber(e),
      await this.ready(),
      set(this._db, STORE_KEYVALUE, "skinTone", e)
    );
  }
  async incrementFavoriteEmojiCount(e) {
    return (
      assertNonEmptyString(e),
      await this.ready(),
      incrementFavoriteEmojiCount(this._db, e)
    );
  }
  async getTopFavoriteEmoji(e) {
    return (
      assertNumber(e),
      await this.ready(),
      (await getTopFavoriteEmoji(this._db, this._custom, e)).map(cleanEmoji)
    );
  }
  set customEmoji(e) {
    this._custom = customEmojiIndex(e);
  }
  get customEmoji() {
    return this._custom.all;
  }
  async _shutdown() {
    await this.ready();
    try {
      await this._lazyUpdate;
    } catch (e) {}
  }
  _clear() {
    this._db = this._ready = this._lazyUpdate = void 0;
  }
  async close() {
    await this._shutdown(), await closeDatabase(this._dbName);
  }
  async delete() {
    await this._shutdown(), await deleteDatabase(this._dbName);
  }
}
export { Database as default };
//# sourceMappingURL=/sm/e9f3c12bef6fe2121cb7a880263cfafb225b382a3825da2f586801f542836439.map
